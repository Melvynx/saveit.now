generator client {
  provider      = "prisma-client-js"
  output        = "../generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

model User {
  id                     String                  @id
  name                   String
  email                  String                  @unique
  emailVerified          Boolean
  image                  String?
  createdAt              DateTime
  updatedAt              DateTime
  stripeCustomerId       String?
  onboarding             Boolean                 @default(false)
  banExpires             DateTime?
  banReason              String?
  banned                 Boolean?
  role                   String?
  unsubscribed           Boolean                 @default(false)
  metadata               Json?
  bookmarks              Bookmark[]
  bookmarkOpens          BookmarkOpen[]
  bookmarkProcessingRuns BookmarkProcessingRun[]
  chatUsages             ChatUsage[]
  chatConversations      ChatConversation[]
  tags                   Tag[]
  accounts               Account[]
  apikeys                Apikey[]
  sessions               Session[]
  subscriptions          Subscription[]

  @@map("user")
}

model Session {
  id             String   @id
  expiresAt      DateTime
  token          String   @unique
  createdAt      DateTime
  updatedAt      DateTime
  ipAddress      String?
  userAgent      String?
  userId         String
  impersonatedBy String?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Apikey {
  id                  String    @id
  name                String?
  start               String?
  prefix              String?
  key                 String
  userId              String
  refillInterval      Int?
  refillAmount        Int?
  lastRefillAt        DateTime?
  enabled             Boolean?
  rateLimitEnabled    Boolean?
  rateLimitTimeWindow Int?
  rateLimitMax        Int?
  requestCount        Int?
  remaining           Int?
  lastRequest         DateTime?
  expiresAt           DateTime?
  createdAt           DateTime
  updatedAt           DateTime
  permissions         String?
  metadata            String?
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("apikey")
}

model Tag {
  id        String        @id @default(cuid())
  name      String
  userId    String
  type      TagType       @default(IA)
  bookmarks BookmarkTag[]
  user      User          @relation(fields: [userId], references: [id])

  @@unique([userId, name])
}

model BookmarkTag {
  bookmarkId String
  tagId      String
  bookmark   Bookmark @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([bookmarkId, tagId])
  @@index([bookmarkId, tagId], map: "idx_bookmark_tag_bookmark")
}

model Bookmark {
  id                     String                  @id @default(ulid())
  userId                 String
  url                    String
  type                   BookmarkType?
  title                  String?
  titleEmbedding         Unsupported("vector")?
  summary                String?
  note                   String?
  preview                String?
  vectorSummary          String?
  vectorSummaryEmbedding Unsupported("vector")?
  faviconUrl             String?
  ogImageUrl             String?
  ogDescription          String?
  metadata               Json?
  status                 BookmarkStatus          @default(PENDING)
  inngestRunId           String?
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  imageDescription       String?
  starred                Boolean                 @default(false)
  read                   Boolean                 @default(false)
  user                   User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  BookmarkChunk          BookmarkChunk[]
  opens                  BookmarkOpen[]
  processingRuns         BookmarkProcessingRun[]
  tags                   BookmarkTag[]

  @@index([userId, type, starred, read, status], map: "idx_bookmark_user_filters")
  @@index([userId, createdAt(sort: Desc)], map: "idx_bookmark_user_created")
  @@index([userId, starred, createdAt(sort: Desc)], map: "idx_bookmark_starred")
  @@index([userId, read, createdAt(sort: Desc)], map: "idx_bookmark_unread")
}

model BookmarkProcessingRun {
  id            String                      @id @default(cuid())
  inngestRunId  String                      @unique
  bookmarkId    String
  userId        String
  status        BookmarkProcessingRunStatus @default(STARTED)
  startedAt     DateTime                    @default(now())
  completedAt   DateTime?
  failureReason String?
  bookmark      Bookmark                    @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
  user          User                        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, startedAt])
  @@index([inngestRunId])
}

model BookmarkChunk {
  id         String                 @id @default(nanoid(7))
  bookmarkId String
  idx        Int
  content    String
  embedding  Unsupported("vector")?
  bookmark   Bookmark               @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
}

model BookmarkOpen {
  id         String   @id @default(nanoid(7))
  bookmarkId String
  userId     String
  openedAt   DateTime @default(now())
  bookmark   Bookmark @relation(fields: [bookmarkId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([bookmarkId, userId])
  @@index([userId, openedAt])
}

model ChatUsage {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model ChatConversation {
  id        String   @id @default(cuid())
  userId    String
  title     String?
  messages  Json     @default("[]")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, updatedAt(sort: Desc)])
}

model Subscription {
  id                   String    @id
  plan                 String
  referenceId          String
  stripeCustomerId     String?
  stripeSubscriptionId String?
  status               String?
  periodStart          DateTime?
  periodEnd            DateTime?
  cancelAtPeriodEnd    Boolean?
  seats                Int?
  user                 User      @relation(fields: [referenceId], references: [id], onDelete: Cascade)

  @@map("subscription")
}

enum TagType {
  USER
  IA
}

enum BookmarkType {
  VIDEO
  ARTICLE
  PAGE
  IMAGE
  YOUTUBE
  TWEET
  PDF
  PRODUCT
}

enum BookmarkStatus {
  PENDING
  PROCESSING
  READY
  ERROR
}

enum BookmarkProcessingRunStatus {
  STARTED
  COMPLETED
  FAILED
}
